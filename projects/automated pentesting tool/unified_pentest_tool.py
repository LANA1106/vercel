#!/usr/bin/env python3
"""
Unified Automated Penetration Testing Tool
Author: Automated Pentest Framework
Version: 3.0
Description: Comprehensive automated penetration testing tool with logging,
            reporting, multi-threaded scanning capabilities, and both basic
            and advanced modes.
"""

import subprocess
import os
import re
import sys
import argparse
import time
import socket
import json
import logging
import threading
from concurrent.futures import ThreadPoolExecutor, as_completed
from datetime import datetime
from urllib.parse import urlparse
from pathlib import Path
import configparser
import hashlib
import ipaddress
from typing import List, Dict, Optional, Tuple

# Configuration settings
CONFIG_FILE = "pentest_config.ini"
DEFAULT_TIMEOUT = 300
MAX_THREADS = 5

class PentestLogger:
    """Centralized logging system for the penetration testing tool"""
    
    def __init__(self, log_file: str = "pentest.log"):
        self.log_file = log_file
        self.setup_logging()
    
    def setup_logging(self):
        """Setup logging configuration"""
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler(self.log_file),
                logging.StreamHandler()
            ]
        )
        self.logger = logging.getLogger(__name__)
    
    def info(self, message: str):
        self.logger.info(message)
        print(f"\033[94m[INFO]\033[0m {message}")
    
    def success(self, message: str):
        self.logger.info(f"SUCCESS: {message}")
        print(f"\033[92m[SUCCESS]\033[0m {message}")
    
    def error(self, message: str):
        self.logger.error(message)
        print(f"\033[91m[ERROR]\033[0m {message}")
    
    def warning(self, message: str):
        self.logger.warning(message)
        print(f"\033[93m[WARNING]\033[0m {message}")

class PentestConfig:
    """Configuration management for the penetration testing tool"""
    
    def __init__(self, config_file: str = CONFIG_FILE):
        self.config_file = config_file
        self.config = configparser.ConfigParser()
        self.load_config()
    
    def load_config(self):
        """Load configuration from file or create default"""
        if os.path.exists(self.config_file):
            self.config.read(self.config_file)
        else:
            self.create_default_config()
    
    def create_default_config(self):
        """Create default configuration file"""
        self.config['DEFAULT'] = {
            'timeout': str(DEFAULT_TIMEOUT),
            'max_threads': str(MAX_THREADS),
            'results_dir': 'pentest_results',
            'enable_logging': 'true'
        }
        
        self.config['NMAP'] = {
            'scan_type': '-sS',
            'additional_flags': '-Pn -sV',
            'output_format': 'normal'
        }
        
        self.config['SQLMAP'] = {
            'risk_level': '1',
            'level': '1',
            'threads': '1'
        }
        
        self.config['HYDRA'] = {
            'threads': '4',
            'timeout': '1800'
        }
        
        self.config['NIKTO'] = {
            'timeout': '600',
            'format': 'txt'
        }
        
        self.config['DIRB'] = {
            'timeout': '900',
            'wordlist': '/usr/share/dirb/wordlists/common.txt'
        }
        
        self.config['WPSCAN'] = {
            'timeout': '1200',
            'enumerate': 'u,t,p'
        }
        
        self.save_config()
    
    def save_config(self):
        """Save configuration to file"""
        with open(self.config_file, 'w') as configfile:
            self.config.write(configfile)
    
    def get(self, section: str, key: str, fallback: str = None):
        """Get configuration value"""
        return self.config.get(section, key, fallback=fallback)
    
    def getint(self, section: str, key: str, fallback: int = None):
        """Get integer configuration value"""
        return self.config.getint(section, key, fallback=fallback)
    
    def getboolean(self, section: str, key: str, fallback: bool = None):
        """Get boolean configuration value"""
        return self.config.getboolean(section, key, fallback=fallback)

class ScanResult:
    """Class to store scan results"""
    
    def __init__(self, tool: str, target: str, success: bool, output_file: str = None):
        self.tool = tool
        self.target = target
        self.success = success
        self.output_file = output_file
        self.timestamp = datetime.now().isoformat()
        self.findings = []
        self.execution_time = 0
    
    def add_finding(self, finding: str):
        """Add a finding to the results"""
        self.findings.append(finding)
    
    def set_execution_time(self, exec_time: float):
        """Set the execution time for the scan"""
        self.execution_time = exec_time
    
    def to_dict(self) -> Dict:
        """Convert result to dictionary for JSON serialization"""
        return {
            'tool': self.tool,
            'target': self.target,
            'success': self.success,
            'output_file': self.output_file,
            'timestamp': self.timestamp,
            'execution_time': self.execution_time,
            'findings': self.findings
        }

class PentestFramework:
    """Main penetration testing framework class"""
    
    def __init__(self):
        self.logger = PentestLogger()
        self.config = PentestConfig()
        self.results: List[ScanResult] = []
        self.target_info = {}
        self.start_time = None
        self.end_time = None
    
    def print_info(self, message: str):
        self.logger.info(message)
    
    def print_success(self, message: str):
        self.logger.success(message)
    
    def print_error(self, message: str):
        self.logger.error(message)
    
    def print_warning(self, message: str):
        self.logger.warning(message)
    
    def validate_target(self, target: str) -> bool:
        """Validate if target is a valid IP address or domain"""
        # Check if it's an IP address
        try:
            ipaddress.ip_address(target)
            return True
        except ValueError:
            pass
        
        # Check if it's a domain
        if re.match(r'^[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?)*$', target):
            try:
                socket.gethostbyname(target)
                return True
            except socket.gaierror:
                self.print_error(f"Could not resolve domain: {target}")
                return False
        
        self.print_error("Invalid target IP or domain.")
        return False
    
    def ensure_http_prefix(self, url: str) -> str:
        """Ensure URL has http:// prefix if not already present"""
        if not url.startswith('http://') and not url.startswith('https://'):
            return f"http://{url}"
        return url
    
    def run_nmap(self, target: str) -> bool:
        """Run Nmap scan on target"""
        self.print_info(f"Starting Nmap scan on {target}")
        result = ScanResult("nmap", target, False, "nmap_scan.txt")
        start_time = time.time()
        
        try:
            nmap_flags = self.config.get('NMAP', 'additional_flags', '-Pn -sS -sV')
            timeout = self.config.getint('DEFAULT', 'timeout', DEFAULT_TIMEOUT)
            
            nmap_command = ["nmap"] + nmap_flags.split() + ["-oN", "nmap_scan.txt", target]
            subprocess.run(nmap_command, check=True, timeout=timeout)
            
            result.success = True
            result.set_execution_time(time.time() - start_time)
            self.print_success("Nmap scan completed. Results saved to nmap_scan.txt")
        except subprocess.CalledProcessError:
            self.print_error("Nmap scan failed.")
        except subprocess.TimeoutExpired:
            self.print_error("Nmap scan timed out.")
        except FileNotFoundError:
            self.print_error("Nmap not found. Please install Nmap.")
        
        self.results.append(result)
        return result.success
    
    def parse_nmap_results(self, file_path: str) -> List[str]:
        """Parse Nmap results to extract web servers"""
        web_servers = []
        try:
            with open(file_path, "r") as file:
                for line in file:
                    if "http" in line.lower():
                        # Look for IP and port in standard Nmap output format
                        ip_match = re.search(r'(\d+\.\d+\.\d+\.\d+)', line)
                        port_match = re.search(r'(\d+)/tcp\s+open', line)
                        if ip_match and port_match:
                            web_servers.append(f"{ip_match.group(1)}:{port_match.group(1)}")
                        else:
                            # Fallback for other potential formats
                            direct_match = re.search(r'(\d+\.\d+\.\d+\.\d+):(\d+)', line)
                            if direct_match:
                                web_servers.append(f"{direct_match.group(1)}:{direct_match.group(2)}")
        except FileNotFoundError:
            self.print_error("Nmap result file not found.")
        
        # Remove duplicates while preserving order
        return list(dict.fromkeys(web_servers))
    
    def run_sqlmap(self, target: str):
        """Run SQLMap scan on target"""
        target = self.ensure_http_prefix(target)
        self.print_info(f"Starting SQLMap scan on {target}")
        result = ScanResult("sqlmap", target, False, "sqlmap_results")
        start_time = time.time()
        
        try:
            risk_level = self.config.get('SQLMAP', 'risk_level', '1')
            level = self.config.get('SQLMAP', 'level', '1')
            
            sqlmap_command = [
                "sqlmap", "-u", target, "--batch", 
                f"--risk={risk_level}", f"--level={level}",
                "--output-dir=sqlmap_results"
            ]
            subprocess_result = subprocess.run(
                sqlmap_command, check=True, capture_output=True, text=True
            )
            
            result.success = True
            result.set_execution_time(time.time() - start_time)
            
            if subprocess_result.stdout:
                if "vulnerable" in subprocess_result.stdout.lower():
                    result.add_finding("SQL injection vulnerability detected")
                    self.print_warning("SQLMap found potential SQL injection vulnerabilities!")
            
            self.print_success(f"SQLMap scan completed for {target}. Results saved to sqlmap_results.")
        except subprocess.CalledProcessError:
            self.print_error(f"SQLMap scan failed for {target}.")
        except FileNotFoundError:
            self.print_error("SQLMap not found. Please install SQLMap.")
        except subprocess.TimeoutExpired:
            self.print_error(f"SQLMap scan timed out for {target}.")
        
        self.results.append(result)
    
    def run_nikto(self, target: str):
        """Run Nikto web vulnerability scan"""
        self.print_info(f"Starting Nikto web vulnerability scan on {target}")
        
        if ":" not in target:
            target = f"{target}:80"
        
        output_file = f"nikto_scan_{target.replace(':', '_')}.txt"
        result = ScanResult("nikto", target, False, output_file)
        start_time = time.time()
        
        try:
            timeout = self.config.getint('NIKTO', 'timeout', 600)
            nikto_command = ["nikto", "-h", target, "-o", output_file]
            subprocess.run(nikto_command, check=True, timeout=timeout)
            
            result.success = True
            result.set_execution_time(time.time() - start_time)
            self.print_success(f"Nikto scan completed for {target}. Results saved to {output_file}")
        except subprocess.CalledProcessError:
            self.print_error(f"Nikto scan failed for {target}.")
        except subprocess.TimeoutExpired:
            self.print_error(f"Nikto scan timed out for {target}.")
        except FileNotFoundError:
            self.print_error("Nikto not found. Please install Nikto.")
        
        self.results.append(result)
    
    def run_dirb(self, target: str):
        """Run Dirb directory brute force"""
        self.print_info(f"Starting Dirb directory brute force on {target}")
        
        output_file = f"dirb_scan_{target.replace(':', '_')}.txt"
        target_url = self.ensure_http_prefix(target)
        result = ScanResult("dirb", target, False, output_file)
        start_time = time.time()
        
        try:
            # Check if wordlist exists
            wordlist = self.config.get('DIRB', 'wordlist', '/usr/share/dirb/wordlists/common.txt')
            if not os.path.exists(wordlist):
                self.print_info("Default wordlist not found. Using built-in small wordlist.")
                wordlist = "dirb_wordlist.txt"
                with open(wordlist, "w") as f:
                    f.write("\n".join([
                        "admin", "login", "wp-admin", "administrator", "phpmyadmin",
                        "dashboard", "wp-content", "upload", "uploads", "backup",
                        "api", "config", "data", "old", "test", "dev", "images",
                        "css", "js", "tmp", "temp", "cache", "logs", "database"
                    ]))
            
            timeout = self.config.getint('DIRB', 'timeout', 900)
            dirb_command = ["dirb", target_url, wordlist, "-o", output_file]
            subprocess.run(dirb_command, check=True, timeout=timeout)
            
            result.success = True
            result.set_execution_time(time.time() - start_time)
            self.print_success(f"Dirb scan completed for {target}. Results saved to {output_file}")
        except subprocess.CalledProcessError:
            self.print_error(f"Dirb scan failed for {target}.")
        except subprocess.TimeoutExpired:
            self.print_error(f"Dirb scan timed out for {target}.")
        except FileNotFoundError:
            self.print_error("Dirb not found. Please install Dirb.")
        
        self.results.append(result)
    
    def run_hydra(self, target: str, service: str):
        """Run Hydra brute force attack"""
        self.print_info(f"Starting Hydra brute force on {target} for service {service}")
        
        # Extract IP from target if it contains a port
        ip = target.split(":")[0]
        result = ScanResult("hydra", f"{ip}:{service}", False, f"hydra_{service}_results.txt")
        start_time = time.time()
        
        try:
            threads = self.config.get('HYDRA', 'threads', '4')
            timeout = self.config.getint('HYDRA', 'timeout', 1800)
            
            if service == "ssh":
                port = "22"
            elif service == "ftp":
                port = "21"
            elif service == "http-post":
                port = "80"
                hydra_command = [
                    "hydra", "-L", "usernames.txt", "-P", "passwords.txt",
                    "-t", threads, ip, "http-post-form",
                    "/login.php:username=^USER^&password=^PASS^:Login failed",
                    "-s", port, "-o", "hydra_http_results.txt"
                ]
            else:
                port = "22"
                service = "ssh"
            
            if service != "http-post":
                hydra_command = [
                    "hydra", "-L", "usernames.txt", "-P", "passwords.txt",
                    "-t", threads, ip, service, "-s", port,
                    "-o", f"hydra_{service}_results.txt"
                ]
            
            subprocess.run(hydra_command, check=True, timeout=timeout)
            
            result.success = True
            result.set_execution_time(time.time() - start_time)
            self.print_success(f"Hydra {service} brute force completed for {target}. Results saved to hydra_{service}_results.txt")
        except subprocess.CalledProcessError:
            self.print_error(f"Hydra {service} brute force failed for {target}.")
        except subprocess.TimeoutExpired:
            self.print_error(f"Hydra {service} brute force timed out for {target}.")
        except FileNotFoundError:
            self.print_error("Hydra not found. Please install Hydra.")
        
        self.results.append(result)
    
    def run_wpscan(self, target: str):
        """Run WPScan for WordPress vulnerabilities"""
        self.print_info(f"Starting WPScan on {target}")
        
        target_url = self.ensure_http_prefix(target)
        output_file = f"wpscan_{target.replace(':', '_').replace('/', '_')}.txt"
        result = ScanResult("wpscan", target, False, output_file)
        start_time = time.time()
        
        try:
            timeout = self.config.getint('WPSCAN', 'timeout', 1200)
            enumerate = self.config.get('WPSCAN', 'enumerate', 'u,t,p')
            
            wpscan_command = [
                "wpscan", "--url", target_url,
                "--enumerate", enumerate,
                "--output", output_file
            ]
            
            subprocess.run(wpscan_command, check=True, timeout=timeout)
            
            result.success = True
            result.set_execution_time(time.time() - start_time)
            self.print_success(f"WPScan completed for {target}. Results saved to {output_file}")
        except subprocess.CalledProcessError:
            self.print_error(f"WPScan failed for {target}.")
        except subprocess.TimeoutExpired:
            self.print_error(f"WPScan timed out for {target}.")
        except FileNotFoundError:
            self.print_error("WPScan not found. Please install WPScan.")
        
        self.results.append(result)
    
    def check_credentials_exist(self):
        """Create sample credential files if they don't exist"""
        if not os.path.exists("usernames.txt") or not os.path.exists("passwords.txt"):
            self.print_info("Creating sample credential files for Hydra...")
            
            # More comprehensive username list
            usernames = [
                "admin", "root", "user", "administrator", "guest", "test",
                "oracle", "postgres", "mysql", "ftp", "mail", "email",
                "web", "www", "http", "apache", "nginx", "tomcat"
            ]
            
            # More comprehensive password list
            passwords = [
                "password", "admin", "123456", "password123", "qwerty", 
                "letmein", "welcome", "root", "toor", "pass", "test",
                "guest", "administrator", "login", "changeme", "default",
                "12345", "abc123", "password1", "admin123", "root123"
            ]
            
            with open("usernames.txt", "w") as f:
                f.write("\n".join(usernames))
            
            with open("passwords.txt", "w") as f:
                f.write("\n".join(passwords))
            
            self.print_success("Created comprehensive credential files. Please update with more specific lists for better results.")
    
    def create_results_directory(self):
        """Create and navigate to results directory"""
        results_dir = self.config.get('DEFAULT', 'results_dir', 'pentest_results')
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        full_results_dir = f"{results_dir}_{timestamp}"
        
        if not os.path.exists(full_results_dir):
            os.makedirs(full_results_dir)
            self.print_info(f"Created results directory: {full_results_dir}")
        
        os.chdir(full_results_dir)
        self.print_info(f"All results will be saved in: {os.path.abspath(full_results_dir)}")
        return full_results_dir
    
    def generate_report(self):
        """Generate a comprehensive report of all scan results"""
        report_file = f"pentest_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        
        total_time = 0
        if self.start_time and self.end_time:
            total_time = self.end_time - self.start_time
        
        report_data = {
            'scan_info': {
                'timestamp': datetime.now().isoformat(),
                'target': self.target_info.get('target', 'Unknown'),
                'total_scans': len(self.results),
                'total_execution_time': total_time
            },
            'results': [result.to_dict() for result in self.results],
            'summary': {
                'successful_scans': sum(1 for r in self.results if r.success),
                'failed_scans': sum(1 for r in self.results if not r.success),
                'total_findings': sum(len(r.findings) for r in self.results),
                'tools_used': list(set(r.tool for r in self.results))
            }
        }
        
        try:
            with open(report_file, 'w') as f:
                json.dump(report_data, f, indent=2)
            self.print_success(f"Comprehensive report generated: {report_file}")
            
            # Generate a simple text summary
            summary_file = f"pentest_summary_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"
            with open(summary_file, 'w') as f:
                f.write("PENETRATION TESTING SUMMARY REPORT\n")
                f.write("=" * 50 + "\n\n")
                f.write(f"Target: {self.target_info.get('target', 'Unknown')}\n")
                f.write(f"Scan Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
                f.write(f"Total Execution Time: {total_time:.2f} seconds\n\n")
                
                f.write("SCAN RESULTS:\n")
                f.write("-" * 20 + "\n")
                for result in self.results:
                    status = "SUCCESS" if result.success else "FAILED"
                    f.write(f"{result.tool.upper()}: {status} ({result.execution_time:.2f}s)\n")
                    if result.findings:
                        for finding in result.findings:
                            f.write(f"  - {finding}\n")
                
                f.write(f"\nSUMMARY:\n")
                f.write("-" * 10 + "\n")
                f.write(f"Total Scans: {len(self.results)}\n")
                f.write(f"Successful: {sum(1 for r in self.results if r.success)}\n")
                f.write(f"Failed: {sum(1 for r in self.results if not r.success)}\n")
                f.write(f"Total Findings: {sum(len(r.findings) for r in self.results)}\n")
            
            self.print_success(f"Text summary generated: {summary_file}")
            
        except Exception as e:
            self.print_error(f"Failed to generate report: {e}")
    
    def run_basic_scan(self, target: str):
        """Run basic penetration testing scan (like original pentest_tool.py)"""
        self.print_info("Running Basic Penetration Testing Scan")
        self.target_info['target'] = target
        self.start_time = time.time()
        
        if not self.validate_target(target):
            return False
        
        # Run Nmap scan
        if not self.run_nmap(target):
            self.print_error("Nmap scan failed. Cannot proceed with basic scan.")
            return False
        
        # Parse results and run SQLMap on discovered web servers
        web_servers = self.parse_nmap_results("nmap_scan.txt")
        if not web_servers:
            self.print_error("No web servers found during the Nmap scan.")
            return False
        
        self.print_success(f"Discovered web servers: {', '.join(web_servers)}")
        
        # Run SQLMap on each discovered web server
        for server in web_servers:
            self.run_sqlmap(server)
        
        self.end_time = time.time()
        return True
    
    def run_advanced_scan(self, target: str, scan_options: Dict):
        """Run advanced penetration testing scan (like enhanced-pentest-tool.py)"""
        self.print_info("Running Advanced Penetration Testing Scan")
        self.target_info['target'] = target
        self.start_time = time.time()
        
        if not self.validate_target(target):
            return False
        
        web_servers = []
        
        # Run Nmap scan if not skipped
        if not scan_options.get('skip_nmap', False):
            if self.run_nmap(target):
                web_servers = self.parse_nmap_results("nmap_scan.txt")
                if web_servers:
                    self.print_success(f"Discovered web servers: {', '.join(web_servers)}")
                else:
                    self.print_info("No web servers found during the Nmap scan.")
                    web_servers = [target]
            else:
                web_servers = [target]
        else:
            self.print_info("Skipping Nmap scan as requested.")
            web_servers = [target]
        
        # Create credential files for Hydra if needed
        if not scan_options.get('skip_hydra', False):
            self.check_credentials_exist()
        
        # Run the selected tools for each discovered web server
        for server in web_servers:
            if not scan_options.get('skip_sqlmap', False):
                self.run_sqlmap(server)
                time.sleep(2)
            
            if not scan_options.get('skip_nikto', False):
                self.run_nikto(server)
                time.sleep(2)
            
            if not scan_options.get('skip_dirb', False):
                self.run_dirb(server)
                time.sleep(2)
            
            if not scan_options.get('skip_wpscan', False):
                self.run_wpscan(server)
                time.sleep(2)
            
            if not scan_options.get('skip_hydra', False):
                ip = server.split(":")[0]
                service = scan_options.get('service', 'ssh')
                self.run_hydra(ip, service)
        
        self.end_time = time.time()
        return True

def main():
    parser = argparse.ArgumentParser(description="Unified Automated Penetration Testing Tool")
    parser.add_argument("-t", "--target", help="Target IP or domain")
    parser.add_argument("-m", "--mode", choices=["basic", "advanced"], default="advanced",
                      help="Scan mode: basic (nmap + sqlmap) or advanced (full suite)")
    
    # Advanced mode options
    parser.add_argument("--skip-nmap", action="store_true", help="Skip Nmap scan")
    parser.add_argument("--skip-sqlmap", action="store_true", help="Skip SQLMap scan")
    parser.add_argument("--skip-nikto", action="store_true", help="Skip Nikto scan")
    parser.add_argument("--skip-dirb", action="store_true", help="Skip Dirb scan")
    parser.add_argument("--skip-hydra", action="store_true", help="Skip Hydra scan")
    parser.add_argument("--skip-wpscan", action="store_true", help="Skip WPScan")
    parser.add_argument("--service", choices=["ssh", "ftp", "http-post"], default="ssh",
                      help="Service for Hydra brute force (ssh, ftp, http-post)")
    parser.add_argument("--no-report", action="store_true", help="Skip report generation")
    
    args = parser.parse_args()
    
    # Initialize framework
    framework = PentestFramework()
    
    framework.print_info("=" * 60)
    framework.print_info("UNIFIED AUTOMATED PENETRATION TESTING TOOL v3.0")
    framework.print_info("=" * 60)
    
    # Create results directory
    results_dir = framework.create_results_directory()
    
    # Get target
    if args.target:
        target = args.target
    else:
        target = input("Enter target IP or domain: ").strip()
    
    # Prepare scan options
    scan_options = {
        'skip_nmap': args.skip_nmap,
        'skip_sqlmap': args.skip_sqlmap,
        'skip_nikto': args.skip_nikto,
        'skip_dirb': args.skip_dirb,
        'skip_hydra': args.skip_hydra,
        'skip_wpscan': args.skip_wpscan,
        'service': args.service
    }
    
    # Run appropriate scan mode
    success = False
    if args.mode == "basic":
        success = framework.run_basic_scan(target)
    else:
        success = framework.run_advanced_scan(target, scan_options)
    
    if success:
        framework.print_success("Penetration testing completed successfully!")
        
        # Generate report unless skipped
        if not args.no_report:
            framework.generate_report()
        
        framework.print_info(f"All results saved in: {os.path.abspath(results_dir)}")
    else:
        framework.print_error("Penetration testing failed or was incomplete.")
        sys.exit(1)

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\n\033[91m[ERROR]\033[0m Execution interrupted by user.")
        sys.exit(0)
    except Exception as e:
        print(f"\n\033[91m[ERROR]\033[0m Unexpected error: {e}")
        sys.exit(1)
